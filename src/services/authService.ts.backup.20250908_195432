import AsyncStorage from '@react-native-async-storage/async-storage';
import { makeApiCall } from './networkService';

export interface User {
  id: string;
  email: string;
  name: string;
  firstName?: string;
  lastName?: string;
  userRole: 'Pet Owner' | 'Pet Sitter';
  role: 'pet_owner' | 'pet_sitter';
  phone?: string;
  age?: number;
  gender?: string;
  address?: string;
  experience?: string;
  hourlyRate?: string;
  aboutMe?: string;
  specialties?: string[];
  email_verified?: boolean;
  phone_verified?: boolean;
  selectedPetTypes?: ('dogs' | 'cats')[];
  selectedBreeds?: string[];
  profileImage?: string;
}

export interface AuthState {
  user: User | null;
  isAuthenticated: boolean;
  isLoading: boolean;
}

class AuthService {
  private static instance: AuthService;
  private currentUser: User | null = null;

  static getInstance(): AuthService {
    if (!AuthService.instance) {
      AuthService.instance = new AuthService();
    }
    return AuthService.instance;
  }

  async login(email: string, password: string): Promise<User> {
    try {
      console.log('Attempting to login with backend API');
      
      // Call the backend login API with timeout
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
      
      const response = await makeApiCall('/api/login', {
        method: 'POST',
        body: JSON.stringify({
          email,
          password,
        }),
        signal: controller.signal,
      });
      
      clearTimeout(timeoutId);

      // Check if response is ok
      if (!response.ok) {
        console.error('Login API error response:', response.status, response.statusText);
        const errorText = await response.text();
        console.error('Error response body:', errorText);
        throw new Error(`Login failed: ${response.status} ${response.statusText}`);
      }

      // Check content type
      const contentType = response.headers.get('content-type');
      if (!contentType || !contentType.includes('application/json')) {
        console.error('Invalid content type:', contentType);
        const responseText = await response.text();
        console.error('Non-JSON response:', responseText);
        throw new Error('Server returned non-JSON response');
      }

      const result = await response.json();
      console.log('Login API response:', result);
      
      if (result.success) {
        console.log('Login successful, user data from backend:', result.user);
        
        // Check if user data exists and has required fields
        if (!result.user || !result.user.id) {
          console.error('Invalid user data received from backend:', result);
          throw new Error('Invalid user data received from server');
        }
        
        // Create user object from backend response
        const user: User = {
          id: result.user.id.toString(),
          email: result.user.email || '',
          name: result.user.name || '',
          firstName: result.user.first_name || '',
          lastName: result.user.last_name || '',
          userRole: result.user.role === 'pet_owner' ? 'Pet Owner' : 'Pet Sitter',
          role: result.user.role || 'pet_owner',
          phone: result.user.phone || '',
          age: result.user.age,
          gender: result.user.gender || '',
          address: result.user.address || '',
          experience: result.user.experience || '',
          hourlyRate: result.user.hourly_rate || '',
          aboutMe: result.user.bio || '',
          specialties: result.user.specialties || [],
          email_verified: result.user.email_verified || false,
          phone_verified: result.user.phone_verified || false,
          selectedPetTypes: result.user.selected_pet_types || [],
          selectedBreeds: result.user.pet_breeds || [],
          profileImage: result.user.profile_image || undefined,
        };

        this.currentUser = user;
        await this.saveUserToStorage(user);
        return user;
      } else {
        console.error('Login failed:', result.message);
        throw new Error(result.message || 'Login failed');
      }
    } catch (error) {
      console.error('Error during login:', error);
      
      // Handle specific error types
      if (error.name === 'AbortError') {
        throw new Error('Login request timed out. Please check your internet connection.');
      } else if (error.message.includes('NetworkError') || error.message.includes('fetch')) {
        throw new Error('Network error. Please check your internet connection.');
      } else if (error.message.includes('JSON Parse error')) {
        throw new Error('Server error. Please try again later.');
      }
      
      throw error;
    }
  }

  async register(userData: {
    email: string;
    password: string;
    name: string;
    userRole: 'Pet Owner' | 'Pet Sitter';
    selectedPetTypes?: ('dogs' | 'cats')[];
    selectedBreeds?: string[];
  }): Promise<User> {
    try {
      console.log('Attempting to register with backend API');
      
      // Call the backend register API with timeout
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
      
      const response = await makeApiCall('/api/register', {
        method: 'POST',
        body: JSON.stringify({
          name: userData.name,
          first_name: userData.name.split(' ')[0],
          last_name: userData.name.split(' ').slice(1).join(' '),
          email: userData.email,
          password: userData.password,
          password_confirmation: userData.password,
          role: userData.userRole === 'Pet Owner' ? 'pet_owner' : 'pet_sitter',
        }),
        signal: controller.signal,
      });
      
      clearTimeout(timeoutId);

      // Check if response is ok
      if (!response.ok) {
        console.error('Register API error response:', response.status, response.statusText);
        const errorText = await response.text();
        console.error('Error response body:', errorText);
        throw new Error(`Registration failed: ${response.status} ${response.statusText}`);
      }

      // Check content type
      const contentType = response.headers.get('content-type');
      if (!contentType || !contentType.includes('application/json')) {
        console.error('Invalid content type:', contentType);
        const responseText = await response.text();
        console.error('Non-JSON response:', responseText);
        throw new Error('Server returned non-JSON response');
      }

      const result = await response.json();
      
      if (result.success) {
        console.log('Registration successful, user data from backend:', result.user);
        
        // Check if user data exists and has required fields
        if (!result.user || !result.user.id) {
          console.error('Invalid user data received from backend:', result);
          throw new Error('Invalid user data received from server');
        }
        
        // Create user object from backend response
        const user: User = {
          id: result.user.id.toString(),
          email: result.user.email || '',
          name: result.user.name || '',
          firstName: result.user.first_name || '',
          lastName: result.user.last_name || '',
          userRole: result.user.role === 'pet_owner' ? 'Pet Owner' : 'Pet Sitter',
          role: result.user.role || 'pet_owner',
          phone: result.user.phone || '',
          age: result.user.age,
          gender: result.user.gender || '',
          address: result.user.address || '',
          experience: result.user.experience || '',
          hourlyRate: result.user.hourly_rate || '',
          aboutMe: result.user.bio || '',
          specialties: result.user.specialties || [],
          email_verified: result.user.email_verified || false,
          phone_verified: result.user.phone_verified || false,
          selectedPetTypes: result.user.selected_pet_types || [],
          selectedBreeds: result.user.pet_breeds || [],
          profileImage: result.user.profile_image || undefined,
        };

        this.currentUser = user;
        await this.saveUserToStorage(user);
        return user;
      } else {
        console.error('Registration failed:', result.message);
        throw new Error(result.message || 'Registration failed');
      }
    } catch (error) {
      console.error('Error during registration:', error);
      
      // Handle specific error types
      if (error.name === 'AbortError') {
        throw new Error('Registration request timed out. Please check your internet connection.');
      } else if (error.message.includes('NetworkError') || error.message.includes('fetch')) {
        throw new Error('Network error. Please check your internet connection.');
      } else if (error.message.includes('JSON Parse error')) {
        throw new Error('Server error. Please try again later.');
      }
      
      throw error;
    }
  }

  async logout(): Promise<void> {
    this.currentUser = null;
    await AsyncStorage.removeItem('user');
  }

  async clearAllData(): Promise<void> {
    this.currentUser = null;
    try {
      // Get all keys first to see what's actually stored
      const allKeys = await AsyncStorage.getAllKeys();
      console.log('Current AsyncStorage keys:', allKeys);
      
      // Clear all keys that might contain user data
      const keysToRemove = allKeys.filter(key => 
        key.includes('user') || 
        key.includes('auth') || 
        key.includes('profile') || 
        key.includes('signup') ||
        key.includes('preference')
      );
      
      console.log('Keys to remove:', keysToRemove);
      
      for (const key of keysToRemove) {
        try {
          await AsyncStorage.removeItem(key);
          console.log(`Removed key: ${key}`);
        } catch (error) {
          console.log(`Could not remove key ${key}:`, error);
        }
      }
      
      console.log('All user data cleared successfully');
    } catch (error) {
      console.error('Error clearing user data:', error);
      // Continue even if there's an error
    }
  }

  async getCurrentUser(): Promise<User | null> {
    if (this.currentUser) {
      console.log('getCurrentUser: Returning cached user:', this.currentUser.email);
      return this.currentUser;
    }
    
    try {
      console.log('getCurrentUser: No cached user, checking AsyncStorage');
      const userData = await AsyncStorage.getItem('user');
      if (userData) {
        console.log('getCurrentUser: Found user data in AsyncStorage:', userData);
        this.currentUser = JSON.parse(userData);
        console.log('getCurrentUser: Parsed user data:', this.currentUser);
        return this.currentUser;
      } else {
        console.log('getCurrentUser: No user data found in AsyncStorage');
      }
    } catch (error) {
      console.error('Error reading user from storage:', error);
    }
    
    return null;
  }

  async updateUserProfile(profileData: Partial<User>): Promise<User> {
    console.log('AuthService: updateUserProfile called with:', profileData);
    console.log('AuthService: Current user:', this.currentUser);
    
    // Validate profileData
    if (!profileData) {
      console.error('AuthService: profileData is null or undefined');
      throw new Error('Profile data is required');
    }
    
    // If no current user exists, create a new one
    if (!this.currentUser) {
      console.log('No current user found, creating new user from profile data:', profileData);
      
      // Ensure we have required fields for creating a new user
      if (!profileData.email) {
        console.error('AuthService: Email is required to create a new user');
        throw new Error('Email is required to create a new user');
      }
      
      const newUser: User = {
        id: profileData.id || Date.now().toString(),
        email: profileData.email || '',
        name: profileData.name || `${profileData.firstName || ''} ${profileData.lastName || ''}`.trim(),
        firstName: profileData.firstName || '',
        lastName: profileData.lastName || '',
        userRole: profileData.userRole || 'Pet Owner',
        role: profileData.userRole === 'Pet Sitter' ? 'pet_sitter' : 'pet_owner',
        phone: profileData.phone || '',
        age: profileData.age || undefined,
        gender: profileData.gender || '',
        address: profileData.address || '',
        experience: profileData.experience || '',
        hourlyRate: profileData.hourlyRate || '',
        aboutMe: profileData.aboutMe || '',
        specialties: profileData.specialties || [],
        email_verified: profileData.email_verified || false,
        phone_verified: profileData.phone_verified || false,
        selectedPetTypes: profileData.selectedPetTypes || [],
        selectedBreeds: profileData.selectedBreeds || [],
        profileImage: profileData.profileImage || undefined,
      };

      this.currentUser = newUser;
      await this.saveUserToStorage(newUser);
      console.log('Created new user in updateUserProfile:', newUser);
      return newUser;
    }

    // Validate current user has required fields
    if (!this.currentUser.id) {
      console.error('AuthService: Current user missing id field:', this.currentUser);
      throw new Error('Current user is missing required id field');
    }
    
    // Ensure current user has firstName and lastName properties
    if (!this.currentUser.firstName) {
      this.currentUser.firstName = '';
    }
    if (!this.currentUser.lastName) {
      this.currentUser.lastName = '';
    }
    
    // Update the current user with new profile data
    const updatedUser = { ...this.currentUser, ...profileData };
    
    // Update the name field if firstName or lastName changed
    if (profileData.firstName || profileData.lastName) {
      const firstName = profileData.firstName || (this.currentUser.firstName || '');
      const lastName = profileData.lastName || (this.currentUser.lastName || '');
      updatedUser.name = `${firstName} ${lastName}`.trim();
    }

    this.currentUser = updatedUser;
    await this.saveUserToStorage(updatedUser);
    console.log('Updated user profile:', updatedUser);
    return updatedUser;
  }

  // New method to store complete user data from backend registration
  async storeUserFromBackend(backendUser: any): Promise<User> {
    console.log('Storing user data from backend:', backendUser);
    
    // Check if backendUser exists and has required fields
    if (!backendUser || !backendUser.id) {
      console.error('Invalid backend user data received:', backendUser);
      throw new Error('Invalid user data received from backend');
    }
    
    const user: User = {
      id: backendUser.id.toString(),
      email: backendUser.email || '',
      name: backendUser.name || '',
      firstName: backendUser.first_name || '',
      lastName: backendUser.last_name || '',
      userRole: backendUser.role === 'pet_owner' ? 'Pet Owner' : 'Pet Sitter',
      role: backendUser.role || 'pet_owner',
      phone: backendUser.phone || '',
      age: backendUser.age,
      gender: backendUser.gender || '',
      address: backendUser.address || '',
      experience: backendUser.experience || '',
      hourlyRate: backendUser.hourly_rate || '',
      aboutMe: backendUser.bio || '',
      specialties: backendUser.specialties || [],
      email_verified: backendUser.email_verified || false,
      phone_verified: backendUser.phone_verified || false,
      selectedPetTypes: backendUser.selected_pet_types || [],
      selectedBreeds: backendUser.pet_breeds || [],
      profileImage: backendUser.profile_image || undefined,
    };

    this.currentUser = user;
    await this.saveUserToStorage(user);
    console.log('User data stored from backend successfully:', user);
    return user;
  }

  async isAuthenticated(): Promise<boolean> {
    const user = await this.getCurrentUser();
    return user !== null;
  }

  private async saveUserToStorage(user: User): Promise<void> {
    try {
      console.log('saveUserToStorage: Saving user to AsyncStorage:', user.email);
      await AsyncStorage.setItem('user', JSON.stringify(user));
      console.log('saveUserToStorage: User saved successfully to AsyncStorage');
    } catch (error) {
      console.error('Error saving user to storage:', error);
    }
  }
}

export default AuthService.getInstance(); 